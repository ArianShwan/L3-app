const { LineAnalyzer, CommentAnalyzer, ComplexityAnalyzer, FunctionAnalyzer, QualityScoreCalculator } = require('./analyzers')
const { BracketValidator, SyntaxValidator, CodeStyleValidator } = require('./validators')

/**
 * CodeAnalyzer - Main analyzer that coordinates all sub-analyzers
 *
 * Follows Single Responsibility Principle (Clean Code, Chapter 2)
 * Delegates work to specialized analyzers
 */
class CodeAnalyzer {
  constructor() {
    this.lineAnalyzer = new LineAnalyzer()
    this.commentAnalyzer = new CommentAnalyzer()
    this.complexityAnalyzer = new ComplexityAnalyzer()
    this.functionAnalyzer = new FunctionAnalyzer()
    this.bracketValidator = new BracketValidator()
    this.syntaxValidator = new SyntaxValidator()
    this.codeStyleValidator = new CodeStyleValidator()
    this.qualityScoreCalculator = new QualityScoreCalculator()
  }

  countLines(content) {
    return this.lineAnalyzer.countLines(content)
  }

  analyzeComments(content, commentPatterns) {
    return this.commentAnalyzer.analyzeComments(content, commentPatterns)
  }

  calculateComplexity(content, languagePatterns) {
    return this.complexityAnalyzer.calculateComplexity(content, languagePatterns)
  }

  analyzeFunctions(content, functionPatterns) {
    return this.functionAnalyzer.analyzeFunctions(content, functionPatterns)
  }

  analyzeCodeQuality(content, functionPatterns) {
    const errors = []
    const warnings = []
    const critical = []

    const codeOnly = this.removeStringsAndComments(content)

    this.runCriticalChecks(content, codeOnly, critical)
    this.runErrorChecks(codeOnly, errors)
    this.runWarningChecks(content, codeOnly, functionPatterns, warnings)

    return {
      summary: {
        critical: critical.length,
        errors: errors.length,
        warnings: warnings.length,
        total: critical.length + errors.length + warnings.length
      },
      details: {
        critical: critical,
        errors: errors,
        warnings: warnings
      },
      score: this.qualityScoreCalculator.calculateQualityScore(critical, errors, warnings)
    }
  }

  removeStringsAndComments(content) {
    return content
      .replace(/"[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*'|`[^`\\]*(?:\\.[^`\\]*)*`/g, '""')
      .replace(/\/\*[\s\S]*?\*\//g, '')
      .replace(/\/\/.*/g, '')
  }

  runCriticalChecks(content, codeOnly, critical) {
    this.bracketValidator.checkBalancedBrackets(codeOnly, critical)
    this.syntaxValidator.checkMissingSemicolons(codeOnly, critical)
    this.syntaxValidator.checkUnclosedStrings(content, critical)
  }

  runErrorChecks(codeOnly, errors) {
    this.codeStyleValidator.checkLooseEquality(codeOnly, errors)
    this.codeStyleValidator.checkUnusedVariables(codeOnly, errors)
    this.syntaxValidator.checkMissingControlStructures(codeOnly, errors)
    this.codeStyleValidator.checkPotentialTypeErrors(codeOnly, errors)
  }

  runWarningChecks(content, codeOnly, functionPatterns, warnings) {
    this.codeStyleValidator.checkConsoleStatements(codeOnly, warnings)
    this.codeStyleValidator.checkLongLines(content, warnings)
    this.codeStyleValidator.checkDeepNesting(codeOnly, warnings)

    const lines = this.lineAnalyzer.countLines(content)
    this.commentAnalyzer.checkCommentRatio(content, lines.total, warnings)
    this.functionAnalyzer.checkFunctionLength(content, functionPatterns, lines.code, warnings)
  }

}

module.exports = CodeAnalyzer
